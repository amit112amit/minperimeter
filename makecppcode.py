#!/usr/bin/env python
# coding: utf-8

import re
import sympy


def generateEFGfunc(zstring, printfile, symmap=None):
    """
    Given a string expression for z=f(x,y), the code in this module generates
    a function that will calculate the first fundamental form terms E, F, G.
    It returns a Numba Jitted function.

    Parameters:
    -----------

    zstring: A string that can be evaluated as a function of x and y
             like '0.555*sin(pi*x)*cos(pi*y)'. It creates a file containing a
             function definition.
    printfile: name of the file to which the generated code should be written
    symmap: A mapping of the symbols used in zexpr to sympy's functions.
            e.g. symmap={'sin': sympy.sin} when zstring = sin(x)

    Returns:
    --------
    getEFG: a function
    """
    r, t = sympy.symbols('r t', real=True, positive=True)
    a, b = sympy.symbols('a b', real=True)
    x = a + r*sympy.cos(t)
    y = b + r*sympy.sin(t)

    # Copy the mappings from `symmap` into the local namespace
    if symmap is not None:
        locals().update(symmap)

    z = eval(zstring, None, locals())
    p = sympy.Matrix([x, y, z])

    pr = p.diff(r)
    pt = p.diff(t)

    E = pr.dot(pr)
    F = pr.dot(pt)
    G = pt.dot(pt)

    # Find all free symbols
    funcargs = set()
    for expr in [E, F, G]:
        for s in expr.free_symbols:
            funcargs.add(s)
    
    # Remove the known free symbols from the set
    for sym in [r, t, a, b]:
        funcargs.remove(sym)
    
    # Create a string representing the remaining free symbols
    if len(funcargs) > 0:
        argstr = 'const scalar r, const scalar t, const scalar a, const scalar b, '
        extraargs = ', const scalar '.join([" "] + [str(sym) for sym in funcargs])
        extraargs = extraargs.lstrip(' ,')
        argstr += extraargs
    else:
        argstr = 'const scalar r, const scalar t, const scalar a, const scalar b'

    codestr = [
        '#ifndef __GENERATEDEFG_CODE_H__',
        '#define __GENERATEDEFG_CODE_H__\n',
        '#include <tuple>',
        '#include "settings.h"\n',
        'typedef std::tuple<scalar, scalar, scalar> tuple3;\n',
        'struct EFGFunc{\n',
        '    tuple3 operator()({0}){{'.format(argstr),
        '        /* Function generated by `generatecode.py` */'
        '\n        //############## Sub-expressions ##############']

    # Now the codegeneration part, first eliminate common sub-expressions
    pow_2 = re.compile('std::pow\((\w+), 2\)')
    exprs = [E, F, G]
    assignto = ['E', 'F', 'G']
    replacements, reduced_exprs = sympy.cse(exprs, optimizations='basic')
    for lhs, rhs in replacements:
        rhs_code = sympy.cxxcode(rhs)
        rhs_code = pow_2.sub('\g<1>*\g<1>', rhs_code)
        codestr.append('        scalar {} = {};'.format(lhs, rhs_code))

    codestr.append('\n        //############## Final Expressions ##############')
    for lhs, rhs in zip(assignto, reduced_exprs):
        rhs_code = sympy.cxxcode(rhs)
        rhs_code = pow_2.sub('\g<1>*\g<1>', rhs_code)
        codestr.append('        scalar {} = {};'.format(lhs, rhs_code))

    codestr.append('\n        return {E, F, G};')
    funccode = '\n'.join(codestr) + '\n    }\n};\n#endif //__GENERATEDEFG_CODE_H__\n'
    funccode = funccode.replace('std::', 'math::')
    funccode = funccode.replace('math::tuple', 'std::tuple')
    funccode = funccode.replace('M_PI', 'PI')

    with open(printfile, 'w') as out:
        out.write(funccode)

    return funccode


def generatefunction(zstring, printfile, symmap=None):
    """
    Given a string expression for z=f(x,y), the code in this module generates
    a function that will calculate the first fundamental form terms E, F, G
    and its derivatives wrt r, t, a and b. Here, x = a + r*cos(t) and 
    y = b + r*sin(t). It returns a Numba Jitted function.

    Parameters:
    -----------
    zstring: A string that can be evaluated as a function of x and y
             like '0.555*sin(pi*x)*cos(pi*y)'. It creates a file containing a
             function definition.
    printfile: name of the file to which the generated code should be written
    symmap: A mapping of the symbols used in zexpr to sympy's functions.
            e.g. symmap={'sin': sympy.sin} when zstring = sin(x)

    Returns:
    --------
    firstfundaformterms: a function
    """
    r, t = sympy.symbols('r t', real=True, positive=True)
    a, b = sympy.symbols('a b', real=True)
    x = a + r*sympy.cos(t)
    y = b + r*sympy.sin(t)

    # Copy the mappings from `symmap` into the local namespace
    if symmap is not None:
        locals().update(symmap)

    z = eval(zstring, None, locals())
    p = sympy.Matrix([x, y, z])

    pr = p.diff(r)
    pt = p.diff(t)

    E = pr.dot(pr)
    F = pr.dot(pt)
    G = pt.dot(pt)
    Er = E.diff(r)
    Fr = F.diff(r)
    Gr = G.diff(r)
    Ea = E.diff(a)
    Fa = F.diff(a)
    Ga = G.diff(a)
    Eb = E.diff(b)
    Fb = F.diff(b)
    Gb = G.diff(b)

    # Find all free symbols
    funcargs = set()
    for expr in [E, F, G, Er, Fr, Gr, Ea, Fa, Ga, Eb, Fb, Gb]:
        for s in expr.free_symbols:
            funcargs.add(s)
    
    # Remove the known free symbols from the set
    for sym in [r, t, a, b]:
        funcargs.remove(sym)
    
    # Create a string representing the remaining free symbols
    if len(funcargs) > 0:
        argstr = 'const scalar r, const scalar t, const scalar a, const scalar b, '
        extraargs = ', const scalar '.join([" "] + [str(sym) for sym in funcargs])
        extraargs = extraargs.lstrip(' ,')
        argstr += extraargs
    else:
        argstr = 'const scalar r, const scalar t, const scalar a, const scalar b'


    codestr = [
        '#ifndef __GENERATED_CODE_H__',
        '#define __GENERATED_CODE_H__\n',
        '#include <tuple>',
        '#include "settings.h"\n',
        'typedef std::tuple<scalar, scalar, scalar, scalar, scalar, scalar, '+ \
        'scalar, scalar, scalar, scalar, scalar, scalar> tuple12;\n',
        'struct firstfundaformterms{\n',
        '    tuple12 operator()({0}){{'.format(argstr),
        '        /* Function generated by `generatecode.py` */'
        '\n        //############## Sub-expressions ##############']

    # Now the codegeneration part, first eliminate common sub-expressions
    pow_2 = re.compile('std::pow\((\w+), 2\)')
    exprs = [E, F, G, Er, Fr, Gr, Ea, Fa, Ga, Eb, Fb, Gb]
    assignto = ['E', 'F', 'G', 'Er', 'Fr', 'Gr',
            'Ea', 'Fa', 'Ga', 'Eb', 'Fb', 'Gb']
    replacements, reduced_exprs = sympy.cse(exprs, optimizations='basic')
    for lhs, rhs in replacements:
        rhs_code = sympy.cxxcode(rhs)
        rhs_code = pow_2.sub('\g<1>*\g<1>', rhs_code)
        codestr.append('        scalar {} = {};'.format(lhs, rhs_code))

    codestr.append('\n        //############## Final Expressions ##############')
    for lhs, rhs in zip(assignto, reduced_exprs):
        rhs_code = sympy.cxxcode(rhs)
        rhs_code = pow_2.sub('\g<1>*\g<1>', rhs_code)
        codestr.append('        scalar {} = {};'.format(lhs, rhs_code))

    codestr.append('\n        return {E, F, G, Er, Fr, Gr, Ea, Fa, Ga, Eb, Fb, Gb};')
    funccode = '\n'.join(codestr) + '\n    }\n};\n#endif //__GENERATED_CODE_H__\n'
    funccode = funccode.replace('std::', 'math::')
    funccode = funccode.replace('math::tuple', 'std::tuple')
    funccode = funccode.replace('M_PI', 'PI')

    with open(printfile, 'w') as out:
        out.write(funccode)
    
    return funccode


if __name__ == "__main__":

    zexpr = '(111/200)*sin(pi*x)*cos(pi*y) + ' + \
            '(2/50)*(cos(5*pi*x)*sin(5*pi*y))'
    symmap={'sin': sympy.sin, 'cos':sympy.cos, 'pi':sympy.pi}
    code = generateEFGfunc(zexpr, 'generatedEFGcode.h', symmap)
    code = generatefunction(zexpr, 'generatedcode.h', symmap)
